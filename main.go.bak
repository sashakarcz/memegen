package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"html/template"
	"io"
	"log"
	"net/http"

	_ "github.com/mattn/go-sqlite3"
	"github.com/gofiber/fiber/v2"
	"github.com/redis/go-redis/v9"
)

// Meme struct (metadata only)
type Meme struct {
	ID         int
	Template   string
	TopText    string
	BottomText string
	URL        string
	Votes      int
}

// Memegen Template struct
type MemeTemplate struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	BlankURL string `json:"blank"`
	Example  struct {
		URL string `json:"url"`
	} `json:"example"`
}

var (
	db         *sql.DB
	redisClient *redis.Client
	memegenAPI = "http://localhost:5000"
	ctx        = context.Background()
)

func main() {
	var err error
	db, err = sql.Open("sqlite3", "./database.db")
	if err != nil {
		log.Fatal(err)
	}
	createTable()

	// Initialize Redis for caching images
	redisClient = redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "",
		DB:       0,
	})

	app := fiber.New()
	app.Static("/static", "./static")

	// Route: Homepage (shows all memes)
	app.Get("/", func(c *fiber.Ctx) error {
		memes := getAllMemes()
		return renderTemplate(c, "index.html", memes)
	})

	// Route: Meme Creation Form
	app.Get("/generate", func(c *fiber.Ctx) error {
		templates := fetchMemegenTemplates()
		return renderTemplate(c, "meme_form.html", templates)
	})

	// Route: Generate Meme
	app.Post("/generate", func(c *fiber.Ctx) error {
		templateName := c.FormValue("template")
		topText := c.FormValue("top")
		bottomText := c.FormValue("bottom")

		memeURL := fmt.Sprintf("%s/images/%s/%s/%s.png", memegenAPI, templateName, topText, bottomText)

		saveMeme(templateName, topText, bottomText, memeURL)
		return c.Redirect("/")
	})

	// Route: Upvote Meme
	app.Post("/vote/:id", func(c *fiber.Ctx) error {
		memeID := c.Params("id")
		_, err := db.Exec("UPDATE memes SET votes = votes + 1 WHERE id = ?", memeID)
		if err != nil {
			return err
		}
		return c.Redirect("/")
	})

	log.Fatal(app.Listen(":8080"))
}

// Create DB table
func createTable() {
	query := `CREATE TABLE IF NOT EXISTS memes (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		template TEXT,
		topText TEXT,
		bottomText TEXT,
		url TEXT,
		votes INTEGER DEFAULT 0
	)`
	_, err := db.Exec(query)
	if err != nil {
		log.Fatal(err)
	}
}

// Fetch all memes
func getAllMemes() []Meme {
	rows, err := db.Query("SELECT id, template, topText, bottomText, url, votes FROM memes ORDER BY votes DESC")
	if err != nil {
		log.Println("Error fetching memes:", err)
		return nil
	}
	defer rows.Close()

	var memes []Meme
	for rows.Next() {
		var meme Meme
		err := rows.Scan(&meme.ID, &meme.Template, &meme.TopText, &meme.BottomText, &meme.URL, &meme.Votes)
		if err != nil {
			log.Println("Error scanning meme:", err)
			continue
		}
		memes = append(memes, meme)
	}
	return memes
}

// Fetch Memegen templates
func fetchMemegenTemplates() []MemeTemplate {
	resp, err := http.Get(memegenAPI + "/templates")
	if err != nil {
		log.Println("Error fetching templates:", err)
		return nil
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	var templates []MemeTemplate
	json.Unmarshal(body, &templates)

	return templates
}

// Save meme metadata
func saveMeme(template, topText, bottomText, url string) {
	_, err := db.Exec("INSERT INTO memes (template, topText, bottomText, url, votes) VALUES (?, ?, ?, ?, 0)", template, topText, bottomText, url)
	if err != nil {
		log.Println("Error inserting meme:", err)
	}
}

// Render HTML template
func renderTemplate(c *fiber.Ctx, templateName string, data interface{}) error {
	tmpl, err := template.ParseFiles("templates/" + templateName)
	if err != nil {
		log.Println("Error parsing template:", err)
		return c.Status(500).SendString("Template rendering error")
	}

	c.Set("Content-Type", "text/html; charset=utf-8")
	return tmpl.Execute(c.Response().BodyWriter(), data)
}

